######
libck2
######

A C++ code library for easily and efficiently loading and productively modifying low- and high-level information
in the game files of `Crusader Kings II`_ (i.e., CK2 / CKII), a product of `Paradox Development Studios`_ (published by `Paradox Interactive`_). Its use cases primarily
target modding (modification of the game through transformation and extension), although it can also enable excellent analysis tools among many other
applications. Eventually, it is planned to support virtually all titles from `PDS`_.

.. _`Crusader Kings II`: https://en.wikipedia.org/wiki/Crusader_Kings_II
.. _`Paradox Development Studios`: https://en.wikipedia.org/wiki/Paradox_Development_Studio
.. _`PDS`: https://en.wikipedia.org/wiki/Paradox_Development_Studio
.. _`Paradox Interactive`: https://www.paradoxinteractive.com/
.. _`HIP`: http://hip.zijistark.com/
.. _`Historical Immersion Project`: http://hip.zijistark.com/

*************************
Past, Present, and Future
*************************

The current incarnation of the library is actually a resumption of what was thought to be an end-of-life fork of
my eldest hand-written parser for CKII game files. Development has finally been resumed, however!

Near-Term Development Plan
==========================

Low-Level API
-------------

Current focuses of new development are primarily on the low-level API, which is primarily focused upon unified parsing and serialization of game files:

- Full update to C++17
- Fully mutable, reference-counted data structures returned by the parser for easier, more natural read-modify-rewrite application implementations
- Ability to programmatically compose parse trees as if generated by the parser
- Ability to parse from an in-memory buffer and serialize to an in-memory buffer
- General expressiveness and programmer productivity improvements for the API

High-Level API
--------------

Once the most important of these low-level API goals have been achieved, development will also include focus upon the library's
preexisting high-level API: updating existing functionality, and adding much more-- more information on that to come soon). The high-level API enables much more productive manipulation and analysis of game data. Note that the high-level API is necessarily game-specific.

Preparing the Low-Level API for Multi-Game Support
--------------------------------------------------

Once the low-level API is otherwise stable, I'll retrofit its lexing engine to support UTF-8 encoded character input (``libck2`` uses 8-bit fixed-width ``cp1252`` character encoding) and all other changes required for support of Paradox's titles newer than CK2. That at least means replacing the lexer and adding wide character support throughout the API.

Multi-Game Support
==================

Major Support for `Crusader Kings III`_
---------------------------------------

Foremost, these upgrades for UTF-8 encoding and such are toward the end of of adding comprehensive support, for both low-level and high-level APIs, for
Paradox's upcoming title `Crusader Kings III`_ (i.e., CK3, a role-playing grand strategy game sequel to CK2). As the author of this library is an established modder (among other things) for Crusader Kings II, you can expect Crusader Kings III support to just as rich if not moreso.

.. _`Crusader Kings III`: https://www.crusaderkings.com/

``libck2`` becomes ``libpdx``
-----------------------------

This library
will be renamed to ``libpdx``, because the low-level API will support all of Paradox's newer titles in
addition to the older ones that it already informally supports (e.g., besides CK2, including but not limited to: `Europa Universalis III`_ and `Victoria II`_). It'll also be a relative cakewalk to begin adding more convenient and reusable high-level APIs for Paradox's other, newer titles once this multi-game support in the low-level API is complete.

.. _`Europa Universalis III`: https://en.wikipedia.org/wiki/Europa_Universalis_III
.. _`Victoria II`: https://en.wikipedia.org/wiki/Victoria_II

However, note that while multi-game high-level API support is intended (with much code being shared between games), it's necessarily game-specific code, so somebody has to actually care about programmatically manipulating or analyzing any given type of the game's data enough for me (or them) to write a reusable implementation for the high-level API, so while CK2 and CK3 will have extensive high-level APIs, it's unknown the degree to which they will be developed for other Paradox titles.

Nevertheless, the current goal is to add ``libpdx`` support for the following additional, actively-developed or upcoming games to at least some degree beyond the ``libpdx`` low-level API support (older games supported too but not included in this list):

- `Crusader Kings II`_ / `Crusader Kings III`_
- `Hearts of Iron IV`_
- `Europa Universalis IV`_
- `Stellaris`_
- `Imperator: Rome`_

.. _`Europa Universalis IV`: https://en.wikipedia.org/wiki/Europa_Universalis_IV
.. _`Hearts of Iron IV`: https://en.wikipedia.org/wiki/Hearts_of_Iron_IV
.. _`Stellaris`: https://en.wikipedia.org/wiki/Stellaris_(video_game)
.. _`Imperator: Rome`: https://en.wikipedia.org/wiki/Imperator:_Rome

Potential Bindings for Python
=============================

If possible, I also intend to provide a C or native C++ API wrapper to provide very efficient Python 3.X bindings to at least the library's core parsing and serialization code, as well as associated data structures and algorithms to optimize their manipulation. The Python bindings will also be wrapped [on the Python end] in 
order to make the library API more Pythonic where it isn't detrimental to efficiency.

This will create a lightning-fast, robust Python library to read/modify/write these games' data, and it will be available to
virtually anyone that can program. In my CK2 modding team (HIP_)'s experience
over the past several years, this task does indeed need extensive acceleration and
careful memory management for any ambitious scripting task, performance an order of magnitude greater than we've ever been able to get out of pure Python implementations, and that's a level of speed and compactness that only a C/C++ backend can provide.

**********
Conclusion
**********

In the end, I want to finally realize this library as a first-class
programming tool for people analyzing, scripting and/or modifying any of these `PDS`_ games or developing further, higher-level tools for them. It should
not only be a read-only API into these games' data, but it should fully support read-modify-write patterns over arbitrary data that may be partially opaque to the programmer, and it should provide high-level convenience classes to jump right into high-level analysis and/or transformation of game data, implemented with very efficient data structures and algorithms.
